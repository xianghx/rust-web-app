<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `pin` mod in crate `rocket_app`."><meta name="keywords" content="rust, rustlang, rust-lang, pin"><title>rocket_app::domain::error::err_msg::_core::pin - Rust</title><link rel="stylesheet" type="text/css" href="../../../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../../../dark.css"><link rel="stylesheet" type="text/css" href="../../../../../../light.css" id="themeStyle"><script src="../../../../../../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Module pin</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li></ul></div><p class='location'><a href='../../../../../index.html'>rocket_app</a>::<wbr><a href='../../../../index.html'>domain</a>::<wbr><a href='../../../index.html'>error</a>::<wbr><a href='../../index.html'>err_msg</a>::<wbr><a href='../index.html'>_core</a></p><script>window.sidebarCurrent = {name: 'pin', ty: 'mod', relpath: '../'};</script><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../../../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../../../../../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><a id="settings-menu" href="../../../../../../settings.html"><img src="../../../../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span class='since' title='Stable since Rust version '></span><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/lib.rs.html#202' title='goto source code'>[src]</a></span><span class='in-band'>Module <a href='../../../../../index.html'>rocket_app</a>::<wbr><a href='../../../../index.html'>domain</a>::<wbr><a href='../../../index.html'>error</a>::<wbr><a href='../../index.html'>err_msg</a>::<wbr><a href='../index.html'>_core</a>::<wbr><a class="mod" href=''>pin</a></span></h1><div class='stability'><div class='stab unstable'><span class=microscope>ðŸ”¬</span> This is a nightly-only experimental API.  (<code>pin</code>)</div></div><div class='docblock'><p>Types which pin data to its location in memory</p>
<p>It is sometimes useful to have objects that are guaranteed to not move,
in the sense that their placement in memory does not change, and can thus be relied upon.</p>
<p>A prime example of such a scenario would be building self-referencial structs,
since moving an object with pointers to itself will invalidate them,
which could cause undefined behavior.</p>
<p>In order to prevent objects from moving, they must be pinned
by wrapping a pointer to the data in the <a href="struct.Pin.html"><code>Pin</code></a> type. A pointer wrapped
in a <code>Pin</code> is otherwise equivalent to its normal version, e.g. <code>Pin&lt;Box&lt;T&gt;&gt;</code>
and <code>Box&lt;T&gt;</code> work the same way except that the first is pinning the value
of <code>T</code> in place.</p>
<p>First of all, these are pointer types because pinned data mustn't be passed around by value
(that would change its location in memory).
Secondly, since data can be moved out of <code>&amp;mut</code> and <code>Box</code> with functions such as <a href="../../std/mem/fn.swap.html"><code>swap</code></a>,
which causes their contents to swap places in memory,
we need dedicated types that prohibit such operations.</p>
<p>However, these restrictions are usually not necessary,
so most types implement the <a href="trait.Unpin.html"><code>Unpin</code></a> auto-trait,
which indicates that the type can be moved out safely.
Doing so removes the limitations of pinning types,
making them the same as their non-pinning counterparts.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">pin</span>)]</span>

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">pin</span>::<span class="ident">Pin</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">marker</span>::<span class="ident">Pinned</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">ptr</span>::<span class="ident">NonNull</span>;

<span class="comment">// This is a self referencial struct since the slice field points to the data field.</span>
<span class="comment">// We cannot inform the compiler about that with a normal reference,</span>
<span class="comment">// since this pattern cannot be described with the usual borrowing rules.</span>
<span class="comment">// Instead we use a raw pointer, though one which is known to not be null,</span>
<span class="comment">// since we know it&#39;s pointing at the string.</span>
<span class="kw">struct</span> <span class="ident">Unmovable</span> {
    <span class="ident">data</span>: <span class="ident">String</span>,
    <span class="ident">slice</span>: <span class="ident">NonNull</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>,
    <span class="ident">_pin</span>: <span class="ident">Pinned</span>,
}

<span class="kw">impl</span> <span class="ident">Unmovable</span> {
    <span class="comment">// To ensure the data doesn&#39;t move when the function returns,</span>
    <span class="comment">// we place it in the heap where it will stay for the lifetime of the object,</span>
    <span class="comment">// and the only way to access it would be through a pointer to it.</span>
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">data</span>: <span class="ident">String</span>) <span class="op">-&gt;</span> <span class="ident">Pin</span><span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;&gt;</span> {
        <span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">Unmovable</span> {
            <span class="ident">data</span>,
            <span class="comment">// we only create the pointer once the data is in place</span>
            <span class="comment">// otherwise it will have already moved before we even started</span>
            <span class="ident">slice</span>: <span class="ident">NonNull</span>::<span class="ident">dangling</span>(),
            <span class="ident">_pin</span>: <span class="ident">Pinned</span>,
        };
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">boxed</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="ident">pinned</span>(<span class="ident">res</span>);

        <span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">NonNull</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="ident">boxed</span>.<span class="ident">data</span>);
        <span class="comment">// we know this is safe because modifying a field doesn&#39;t move the whole struct</span>
        <span class="kw">unsafe</span> {
            <span class="kw">let</span> <span class="ident">mut_ref</span>: <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">Self</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Pin</span>::<span class="ident">as_mut</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">boxed</span>);
            <span class="ident">Pin</span>::<span class="ident">get_mut_unchecked</span>(<span class="ident">mut_ref</span>).<span class="ident">slice</span> <span class="op">=</span> <span class="ident">slice</span>;
        }
        <span class="ident">boxed</span>
    }
}

<span class="kw">let</span> <span class="ident">unmoved</span> <span class="op">=</span> <span class="ident">Unmovable</span>::<span class="ident">new</span>(<span class="string">&quot;hello&quot;</span>.<span class="ident">to_string</span>());
<span class="comment">// The pointer should point to the correct location,</span>
<span class="comment">// so long as the struct hasn&#39;t moved.</span>
<span class="comment">// Meanwhile, we are free to move the pointer around.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">still_unmoved</span> <span class="op">=</span> <span class="ident">unmoved</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">still_unmoved</span>.<span class="ident">slice</span>, <span class="ident">NonNull</span>::<span class="ident">from</span>(<span class="kw-2">&amp;</span><span class="ident">still_unmoved</span>.<span class="ident">data</span>));

<span class="comment">// Since our type doesn&#39;t implement Unpin, this will fail to compile:</span>
<span class="comment">// let new_unmoved = Unmovable::new(&quot;world&quot;.to_string());</span>
<span class="comment">// std::mem::swap(&amp;mut *still_unmoved, &amp;mut *new_unmoved);</span></pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class='unstable module-item'>
                           <td><a class="struct" href="struct.Pin.html"
                                  title='struct rocket_app::domain::error::err_msg::_core::pin::Pin'>Pin</a></td>
                           <td class='docblock-short'>
                               [<div class='stab unstable'>Experimental</div>] <p>A pinned pointer.</p>

                           </td>
                       </tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>â†‘</kbd></dt><dd>Move up in search results</dd><dt><kbd>â†“</kbd></dt><dd>Move down in search results</dd><dt><kbd>â†¹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../../../../../../";window.currentCrate = "rocket_app";</script><script src="../../../../../../aliases.js"></script><script src="../../../../../../main.js"></script><script defer src="../../../../../../search-index.js"></script></body></html>